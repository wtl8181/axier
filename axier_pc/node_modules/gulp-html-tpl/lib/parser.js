const beautifyHTML = require('js-beautify').html;
const logUtil = require('gulp-util').log;
const FileMgr = require('./filemgr');

function parseAttribute(str) {
	const attributes = {};
	String(str).replace(/(\w+)="([^"]*?)"/g, function withContent(_, name, content) {
		let value = content.trim();
		const numberic = Number(value);
		if (!isNaN(numberic)) {
			value = numberic;
		} else if (/^(false|true)$/i.test(value)) {
			value = value.toLowerCase() === 'true';
		}
		attributes[name] = value;
		return '';
	}).split(/\s+/).forEach(function noContent(name) {
		const prop = name.trim();
		if (/^\w+$/.test(prop)) {
			attributes[prop] = prop;
		}
	});
	return attributes;
}

function parseInnerHTML(str) {
	try {
		/* eslint-disable no-eval */
		const data = eval(`(${str})`);
		/* eslint-enable no-eval */
		if (data && typeof data === 'object') {
			return data;
		}
	/* eslint-disable no-empty */
	} catch (e) {}
	/* eslint-enable no-empty */
	const re = /<fragment[^>]*?id="(\w+)">([\s\S]*?)<\/fragment>/gi;
	const data = {};
	while (re.test(str)) {
		const value = RegExp.$2.trim();
		if (value) {
			data[RegExp.$1.trim()] = value;
		}
	}
	return data;
}


module.exports = function parse(args) {
	const config = Object(args);
	const tplTag = String(config.tag || 'template').toLowerCase();
	const dataTag = config.dataTag ? config.dataTag.toLowerCase() : false;
	const renderEngine = typeof config.engine === 'function' ? config.engine : null;
	const beautifyConf = Object.assign({
		indent_size: 4,
		indent_char: '\t',
		indent_with_tabs: true,
		preserve_newlines: true,
		max_preserve_newlines: 1
	}, config.beautify);
	const fileMgr = new FileMgr(config.paths);
	let log = logUtil;
	if (typeof config.log === 'function') {
		log = config.log;
	} else if (config.log === false) {
		log = Function.prototype;
	}

	function parseFile(src, data) {
		const content = fileMgr.readFile(src);
		if (content) {
			/* eslint-disable no-use-before-define */
			return parseContent(content, src, data);
			/* eslint-enable no-use-before-define */
		}
		log(`Template not found or empty.\nPath: ${src}`);
		return '<!--template not found or empty-->';
	}

	function parseContent(content, base, topData) {
		if (!content) {
			return '';
		}

		let selfData = Object.assign({}, topData);
		let html = content.toString();

		if (dataTag) {
			const re = new RegExp(`<${dataTag}\\b[\\s\\S]*?>([\\s\\S]*?)<\\/${dataTag}>`, 'gi');
			html = html.replace(re, function seperateDataTag(_, textContent) {
				try {
					/* eslint-disable no-eval */
					const data = eval(`(${textContent})`);
					/* eslint-enable no-eval */
					if (data && typeof data === 'object') {
						selfData = Object.assign({}, data, selfData);
					}
				/* eslint-disable no-empty */
				} catch (e) {}
				/* eslint-enable no-empty */
				return '';
			});
		}

		html = renderEngine(html, selfData);

		if (!html) {
			log(`Render error.\nBase: ${base}`);
			return '<!--render error-->';
		}

		const re = new RegExp(`<${tplTag}([\\s\\S]*?)>([\\s\\S]*?)<\\/${tplTag}>`, 'gi');
		const loadTpl = html.replace(re, function render(_, attrText, innerHTML) {
			const attribute = parseAttribute(attrText);
			const src = attribute.src;
			if (src) {
				const file = fileMgr.find(src, base);
				if (file) {
					const jsonData = parseInnerHTML(innerHTML);
					const data = Object.assign({}, selfData, attribute, jsonData);
					return parseFile(file, data);
				}
				log(`Template not found or empty.\nPath: ${src}\nBase: ${base}`);
				return '<!--template not found or empty-->';
			}
			log(`Undefined src.\nBase: ${base}`);
			return '<!--undefined src-->';
		});
		return beautifyHTML(loadTpl, beautifyConf);
	}

	return { parseContent, parseFile };
};